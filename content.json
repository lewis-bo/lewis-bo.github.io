{"meta":{"title":"好记性不如烂笔头","subtitle":"In me the tiger sniffs the rose","description":"JAVA|PYTHON|GIRL","author":"lewis","url":"http://www.note4u.cn","root":"/"},"pages":[{"title":"关于我","date":"un11fin11","updated":"un11fin11","comments":true,"path":"about/index.html","permalink":"http://www.note4u.cn/about/index.html","excerpt":"","text":"1这个人太懒了，什么都没留下！"},{"title":"标签","date":"un66fin66","updated":"un66fin66","comments":true,"path":"tags/index.html","permalink":"http://www.note4u.cn/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"un66fin66","updated":"un66fin66","comments":true,"path":"categories/index.html","permalink":"http://www.note4u.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"http-数据提交方式","slug":"http/http-数据提交方式","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/11/11/http/http-数据提交方式/","link":"","permalink":"http://www.note4u.cn/2019/11/11/http/http-数据提交方式/","excerpt":"","text":"纯加深记忆贴:首先http是一次请求，一次响应。 一般都是server端处理完请求，主动关闭连接。 1.http requestrequest的结构&lt;请求行&gt;&lt;请求头&gt;&lt;请求体&gt;具体结构如下:123+ 第一行 &lt;请求方法&gt;(POST、GET、PUT、D\bELETE) &lt;URL&gt; &lt;协议/版本&gt;+ 第二行 &lt;请求头&gt;(content-Type, content-length)+ 第三行 &lt;请求体&gt;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://www.note4u.cn/tags/http/"},{"name":"java","slug":"java","permalink":"http://www.note4u.cn/tags/java/"}]},{"title":"kmp算法","slug":"algorithm/kmp","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2019/10/21/algorithm/kmp/","link":"","permalink":"http://www.note4u.cn/2019/10/21/algorithm/kmp/","excerpt":"","text":"假如我们从字符串S中匹配一个子串T(模式串)。 很容易想到的就是2层循环，挨个比对。代码示例如下：123456789101112131415public static Integer match(String S, String T) &#123; for (int i = 0; i &lt; (S.length() - T.length() + 1); i++) &#123; int index = i; for (int j = 0; j &lt; T.length(); j++, index++) &#123; if (S.charAt(index) != T.charAt(j)) &#123; break; &#125; &#125; if (index == (i + T.length())) &#123; return i; &#125; &#125; return null;&#125; 设S=”ABCABYABCABBCABCABX”, T=”ABCABX”。如图所示:S和T挨个对比，如果出现失配的情况。 则T右移一位。若S的长度为m， T的长度为n, 显而易见，时间复杂度为O(m*n); 那么问题来了， 有没有更加效率的算法？仔细观察第一次匹配的时候是在S[5]处失配的。反之，则说明S[0]至S[4]是匹配的。假如T[0]至T[4]各不相同, 我们还有必要一位一位的右移T，在挨个比对吗？是否直接可以从S[5]处和T[0]开始匹配。 同理, S[0]至S[4]若存在首尾相同的子串， 我们是否可以直接移动到下一个相同子串的位置。这种字符串匹配算法即KMP算法。 假如在 T[0]处失配，前面无其他字符，则从T[0]对应S的位置的下一位开始匹配， T[1]处失配, 前面字符为A, 则从T[1]对应S的位置和T[0]匹配, T[2]处失配, 前面字符为AB, 则从T[2]对应S位置和T[0]匹配, T[3]处失配, 前面字符为ABC, 则从T[3]对应S位置和T[0]匹配, T[4]处失配, 前面字符为ABCA，存在首尾子串’A’, 则从T[4]对应S位置和T[1]匹配(在T[4]处失配, 说明T[0]至T[3]和对应S的位置匹配, 又T[0]==T[3]即’A’, 故可直接用T[1]和S失配处开始匹配) T[5]处失配, 前面字符为ABCAB，存在首尾子串’AB’, 同理T[4], 可直接从T[2]处和S失配处匹配 所以KMP算法的核心就是获取匹配模式子串对应各个位置失配时, 下一次匹配需回溯的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 获取模式串的next数组 * @param regex * @return */public static int[] next(String regex) &#123; int[] next = new int[regex.length()]; next[0] = 0; next[1] = 0; for (int i = 2; i &lt; regex.length(); i++) &#123; int max = 0; int index = 1; while (index &lt; i) &#123; if (regex.substring(0, index).equals(regex.substring( i - index, i))) &#123; max = index; &#125; index ++; &#125; next[i] = max; &#125; return next;&#125;/** * kmp算法实现 * @param str * @param regex * @return */public static Integer getIndex(String str, String regex) &#123; /** * 获取next数组 */ int[] next = next(regex); int index = 0, cursor = 0; while (index &lt; str.length() &amp;&amp; cursor &lt; regex.length()) &#123; if (str.charAt(index) == regex.charAt(cursor)) &#123; index ++; cursor ++; &#125; else &#123; if (cursor == 0) &#123; index ++; &#125; cursor = next[cursor]; &#125; &#125; return cursor == regex.length() ? index - cursor : null;&#125; next数组优化设S=ababaaabxxabcde, T=ababaaaba。按照上面算法求出对的next数组为000123112则首次匹配时候, 模式串在T[8]处失配, 又next[8] == 2。故下一次匹配从T[2]开始和S[8]进行匹配。 观察得知: T[2]==’a’, T[8]==’a’, 既然T[8]和S[8]不匹配,且T[2]==T[8], 故T[2]和S[8]肯定也失配, 则可从next[2]==0处开始匹配,省略S[8]和T[2]匹配。性能得到提升 由此可从next得出nextval数组的计算过程。还以上述T为例 T[0]处失配, next[0]=0, nextval[0]=0; T[1]处失配, next[1]=0, nextval[1]=0; T[2]处失配, next[2]=0, nextval[2]=0; T[3]处失配, next[3]=1, (T[1]==’b’) == (T[3]==’b’)。 则在T[3]失配时候, 可直接从T[1]处开始匹配, 故nextval[3]=0; T[4]处失配, next[4]=2, (T[2]==’a’) == (T[4]==’a’)。 则在T[4]失配时候, 可直接从T[2]处开始匹配, 故nextval[4]=0; T[5]处失配, next[5]=3, (T[3]==’b’) != (T[5]==’a’)。 则在T[5]失配时候, 还是维持原值。 故nextval[5]=3; T[6]处失配, next[6]=1, (T[1]==’b’) != (T[6]==’a’)。 则在T[6]失配时候, 还是维持原值。 故nextval[6]=1; T[7]处失配, next[7]=1, (T[1]==’b’) == (T[7]==’b’)。 则在T[7]失配时候, 可从T[1]处开始匹配, 故nextval[7]=0; T[8]处失配, next[8]=2, (T[2]==’a’) == (T[8]==’a’)。 则在T[8]失配时候, 可从T[2]处开始匹配, 故nextval[8]=0; 如下： next:000123112nextval:000003100 12345678910111213141516171819public static int[] nextval(String regex) &#123; int[] nextval = new int[regex.length()]; nextval[0] = 0; nextval[1] = 0; for (int i = 2; i &lt; regex.length(); i++) &#123; int max = 0; int index = 1; while (index &lt; i) &#123; if (regex.substring(0, index).equals(regex.substring( i - index, i))) &#123; max = index; &#125; index ++; &#125; nextval[i] = max; if (regex.charAt(max) == regex.charAt(i)) &#123; nextval[i] = nextval[max]; &#125; &#125; return nextval; 匹配方法可直接把next方法改成nextval方法即可。 next函数另一种计算方式, 具体参考下方博客12345678910111213public static int[] next(char[] chars) &#123; int[] next = new int[chars.length]; next[0] = -1; int i = 0, j = -1; while (i &lt; chars.length - 1) &#123; if (j == -1 || chars[i] == chars[j]) &#123; next[++i] = ++j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125; 参考博客","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/tags/算法/"}]},{"title":"求大于某个数的最小2次幂","slug":"java/求大于某个数的最小2次幂","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/08/29/java/求大于某个数的最小2次幂/","link":"","permalink":"http://www.note4u.cn/2019/08/29/java/求大于某个数的最小2次幂/","excerpt":"","text":"今天闲来功夫看了下ArrayDequ的源码。 发现有个计算数组初始化容量的方法设计特别巧妙。如下:123456789101112131415161718private static int calculateSize(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; return initialCapacity;&#125; 假如给定数字17， 我们现在要求大于17的最小2次幂数。 该怎么求呢？17的二进制为:(以8位为例)100010001 则将上述2进制变换成如下图 然后转换成10进制或者 转换成10进制后加1进位。 文章开头所说的算法则就是采用第二种思路。 通过移位和位或运算，将低位0全部转换为1。 然后再加上1。 ps：因为java中 int类型的是32位, 故需要移位(1 + 2 + 4 + 8 + 16)。","categories":[{"name":"java","slug":"java","permalink":"http://www.note4u.cn/categories/java/"}],"tags":[]},{"title":"linux-buff-cache","slug":"linux/linux-buff-cache","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/08/26/linux/linux-buff-cache/","link":"","permalink":"http://www.note4u.cn/2019/08/26/linux/linux-buff-cache/","excerpt":"","text":"linux系统 buff/cache回收 相关命令： top命令查看对应进程的相关信息vmstat 统计虚拟内存 相关链接linux中的cache真的能被回收吗谁吃了我的Linux内存?pcstat查看linux cache工具","categories":[{"name":"linux","slug":"linux","permalink":"http://www.note4u.cn/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.note4u.cn/tags/linux/"}]},{"title":"PreparedStatement之executeBatch","slug":"mysql/mysql-insert-batch","date":"un66fin66","updated":"un22fin22","comments":true,"path":"2019/07/20/mysql/mysql-insert-batch/","link":"","permalink":"http://www.note4u.cn/2019/07/20/mysql/mysql-insert-batch/","excerpt":"","text":"昨天有同事问, 自己代码批量提交，效率特别慢，每次插入1W条数据，大概需要40多秒。检查了下代码，jdbc链接，提交。 大概如下：1234567891011121314151617181920public static void main(String[] args) &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection connection = DriverManager.getConnection(&quot;&quot;); connection.setAutoCommit(false); PreparedStatement statement = connection.prepareStatement(&quot;&quot;); for (int i = 0; i &lt; 100; i++) &#123; /** * statement赋值操作 * */ statement.addBatch(); &#125; statement.executeBatch(); connection.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 123456789代码没有发现具体什么问题。怀疑最终提交到mysql不是期望 insert into test (id, name) values(1, &apos;lucy&apos;), (2, &apos;lili&apos;), (3, &apos;张三&apos;)...;（multi-values)而是insert into test (id, name) values (1, &apos;lucy&apos;);insert into test (id, name) values(2, &apos;lili&apos;);insert into test (id, name) values(3, &apos;张三&apos;); (multi-query)这种方式。 故打开mysql的访问日志。如下 1.1 查看mysql日志是否打开123456789root@(none) 01:46:06&gt;show variables like &apos;%gen%&apos;;+----------------------------------------+-------------------------------+| Variable_name | Value |+----------------------------------------+-------------------------------+| auto_generate_certs | ON || general_log | OFF || general_log_file | /data/mysql3306/log/query.log || sha256_password_auto_generate_rsa_keys | ON |方式日志没有打开。 1.2 打开mysql日志12root@(none) 01:46:15&gt;set GLOBAL general_log=1;也可以通过修改my.cnf文件配置处理。 通过执行日志发现。果然是通过 multi-query这种方式提交的。 接下来就是各种巴拉巴拉查源码、文档。 见详细博客MySQL之rewriteBatchedStatements 另外 mysql驱动版本需要升级到5.1.37以上。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.note4u.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.note4u.cn/tags/mysql/"},{"name":"batch","slug":"batch","permalink":"http://www.note4u.cn/tags/batch/"}]},{"title":"tomcat-server-xml","slug":"tomcat/tomcat-server-xml","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/07/04/tomcat/tomcat-server-xml/","link":"","permalink":"http://www.note4u.cn/2019/07/04/tomcat/tomcat-server-xml/","excerpt":"","text":"详解Tomcat 配置文件server.xm 转自编程迷思-配置文件server.xm 前言 Tomcat隶属于Apache基金会，是开源的轻量级Web应用服务器，使用非常广泛。server.xml是Tomcat中最重要的配置文件，server.xml的每一个元素都对应了Tomcat中的一个组件；通过对xml文件中元素的配置，可以实现对Tomcat中各个组件的控制。因此，学习server.xml文件的配置，对于了解和使用Tomcat至关重要。本文将通过实例，介绍server.xml中各个组件的配置，并详细说明Tomcat各个核心组件的作用以及各个组件之间的相互关系。说明：由于server.xml文件中元素与Tomcat中组件的对应关系，后文中为了描述方便，“元素”和“组件”的使用不严格区分。如果觉得文章对你有帮助，欢迎点赞或转载。文章有疏漏之处，欢迎批评指正。目录一、一个server.xml配置实例二、server.xml文档的元素分类和整体结构 1、整体结构 2、元素分类三、核心组件 1、Server 2、Service 3、Connector 4、Engine 5、Host 6、Context四、核心组件的关联 1、整体关系 2、如何确定请求由谁处理？ 3、如何配置多个服务五、其他组件 1、Listener 2、GlobalNamingResources与Realm 3、Valve六、参考文献一、一个server.xml配置实例server.xml位于$TOMCAT_HOME/conf目录下；下面是一个server.xml实例。后文中将结合该实例讲解server.xml中，各个元素的含义和作用；在阅读后续章节过程中，可以对照该xml文档便于理解。 1 &lt;Server port=”8005” shutdown=”SHUTDOWN”&gt; 2 &lt;Listener className=”org.apache.catalina.startup.VersionLoggerListener” /&gt; 3 &lt;Listener className=”org.apache.catalina.core.AprLifecycleListener” SSLEngine=”on” /&gt; 4 &lt;Listener className=”org.apache.catalina.core.JasperListener” /&gt; 5 &lt;Listener className=”org.apache.catalina.core.JreMemoryLeakPreventionListener” /&gt; 6 &lt;Listener className=”org.apache.catalina.mbeans.GlobalResourcesLifecycleListener” /&gt; 7 &lt;Listener className=”org.apache.catalina.core.ThreadLocalLeakPreventionListener” /&gt; 8 9 &lt;GlobalNamingResources&gt;10 &lt;Resource name=”UserDatabase” auth=”Container”11 type=”org.apache.catalina.UserDatabase”12 description=”User database that can be updated and saved”13 factory=”org.apache.catalina.users.MemoryUserDatabaseFactory”14 pathname=”conf/tomcat-users.xml” /&gt;15 &lt;/GlobalNamingResources&gt;1617 &lt;Service name=”Catalina”&gt;18 &lt;Connector port=”8080” protocol=”HTTP/1.1”19 connectionTimeout=”20000”20 redirectPort=”8443” /&gt;21 &lt;Connector port=”8009” protocol=”AJP/1.3” redirectPort=”8443” /&gt;22 &lt;Engine name=”Catalina” defaultHost=”localhost”&gt;23 &lt;Realm className=”org.apache.catalina.realm.LockOutRealm”&gt;24 &lt;Realm className=”org.apache.catalina.realm.UserDatabaseRealm”25 resourceName=”UserDatabase”/&gt;26 &lt;/Realm&gt;2728 &lt;Host name=”localhost” appBase=”webapps”29 unpackWARs=”true” autoDeploy=”true”&gt;30 &lt;Valve className=”org.apache.catalina.valves.AccessLogValve” directory=”logs”31 prefix=”localhost_access_log.” suffix=”.txt”32 pattern=”%h %l %u %t &amp;quot;%r&amp;quot; %s %b” /&gt;33 &lt;/Host&gt;34 &lt;/Engine&gt;35 &lt;/Service&gt;36 &lt;/Server&gt;二、server.xml文档的元素分类和整体结构1、整体结构server.xml的整体结构如下： 1 &lt;Server&gt; 2 &lt;Service&gt; 3 &lt;Connector /&gt; 4 &lt;Connector /&gt; 5 &lt;Engine&gt; 6 &lt;Host&gt; 7 &lt;Context /&gt;&lt;!– 现在常常使用自动部署，不推荐配置Context元素，Context小节有详细说明 –&gt; 8 &lt;/Host&gt; 9 &lt;/Engine&gt;10 &lt;/Service&gt;11 &lt;/Server&gt;该结构中只给出了Tomcat的核心组件，除了核心组件外，Tomcat还有一些其他组件，下面介绍一下组件的分类。2、元素分类server.xml文件中的元素可以分为以下4类：（1）顶层元素：&lt;Server&gt;和&lt;Service&gt;&lt;Server&gt;元素是整个配置文件的根元素，&lt;Service&gt;元素则代表一个Engine元素以及一组与之相连的Connector元素。（2）连接器：&lt;Connector&gt;&lt;Connector&gt;代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。（3）容器：&lt;Engine&gt;&lt;Host&gt;&lt;Context&gt;容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。（4）内嵌组件：可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。下面将详细介绍Tomcat中各个核心组件的作用，以及相互之间的关系。三、核心组件本部分将分别介绍各个核心组件的作用、特点以及配置方式等。1、ServerServer元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。在第一部分的例子中，在最外层有一个&lt;Server&gt;元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。2、ServiceService的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口，后文会有介绍。3、ConnectorConnector的主要功能，是接收连接请求，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：1 &lt;Connector port=”8080” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt;2 &lt;Connector port=”8009” protocol=”AJP/1.3” redirectPort=”8443” /&gt;（1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。在这个例子中，Tomcat监听HTTP请求，使用的是8080端口，而不是正式的80端口；实际上，在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。（2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图(图片来源)：关于Connector的更多内容，可以参考我的另一篇文章：详解tomcat的连接数与线程池4、EngineEngine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。前面已经提到过，Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。在第一部分的例子中，Engine的配置语句如下：1 &lt;Engine name=”Catalina” defaultHost=”localhost”&gt;其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。5、Host（1）Engine与HostHost是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。（2）Host的作用Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。客户端通常使用主机名来标识它们希望连接的服务器；该主机名也会包含在HTTP请求头中。Tomcat从HTTP头中提取出主机名，寻找名称匹配的主机。如果没有匹配，请求将发送至默认主机。因此默认主机不需要是在DNS服务器中注册的网络名，因为任何与所有Host名称不匹配的请求，都会路由至默认主机。（3）Host的配置在第一部分的例子中，Host的配置如下：1 &lt;Host name=”localhost” appBase=”webapps” unpackWARs=”true” autoDeploy=”true”&gt;下面对其中配置的属性进行说明：name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关；将在下一节(Context)中介绍。6、Context（1）Context的作用Context元素代表在特定虚拟主机上运行的一个Web应用。在后文中，提到Context、应用或Web应用，它们指代的都是Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。Context是Host的子容器，每个Host中可以定义任意多的Context元素。在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。（2）Web应用自动部署Host的配置要开启Web应用的自动部署，需要配置所在的虚拟主机；配置的方式就是前面提到的Host元素的deployOnStartup和autoDeploy属性。如果deployOnStartup和autoDeploy设置为true，则tomcat启动自动部署：当检测到新的Web应用或Web应用的更新时，会触发应用的部署(或重新部署)。二者的主要区别在于，deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用；autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新。除此之外，二者的处理相似。通过配置deployOnStartup和autoDeploy可以开启虚拟主机自动部署Web应用；实际上，自动部署依赖于检查是否有新的或更改过的Web应用，而Host元素的appBase和xmlBase设置了检查Web应用更新的目录。其中，appBase属性指定Web应用所在的目录，默认值是webapps，这是一个相对路径，代表Tomcat根目录下webapps文件夹。xmlBase属性指定Web应用的XML配置文件所在的目录，默认值为conf/&lt;engine_name&gt;/&lt;host_name&gt;，例如第一部分的例子中，主机localhost的xmlBase的默认值是$TOMCAT_HOME/conf/Catalina/localhost。检查Web应用更新 一个Web应用可能包括以下文件：XML配置文件，WAR包，以及一个应用目录(该目录包含Web应用的文件结构)；其中XML配置文件位于xmlBase指定的目录，WAR包和应用目录位于appBase指定的目录。Tomcat按照如下的顺序进行扫描，来检查应用更新：A、扫描虚拟主机指定的xmlBase下的XML配置文件B、扫描虚拟主机指定的appBase下的WAR文件C、扫描虚拟主机指定的appBase下的应用目录&lt;Context&gt;元素的配置Context元素最重要的属性是docBase和path，此外reloadable属性也比较常用。docBase指定了该Web应用使用的WAR包路径，或应用目录。需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，docBase不在appBase目录中，才需要指定；如果docBase指定的WAR包或应用目录就在docBase中，则不需要指定，因为Tomcat会自动扫描appBase中的WAR包和应用目录，指定了反而会造成问题。path指定了访问该Web应用的上下文路径，当请求到来时，Tomcat根据Web应用的 path属性与URI的匹配程度来选择Web应用处理相应请求。例如，Web应用app1的path属性是”/app1”，Web应用app2的path属性是”/app2”，那么请求/app1/index.html会交由app1来处理；而请求/app2/index.html会交由app2来处理。如果一个Context元素的path属性为””，那么这个Context是虚拟主机的默认Web应用；当请求的uri与所有的path都不匹配时，使用该默认Web应用来处理。但是，需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，不能指定path属性，path属性由配置文件的文件名、WAR文件的文件名或应用目录的名称自动推导出来。如扫描Web应用时，发现了xmlBase目录下的app1.xml，或appBase目录下的app1.WAR或app1应用目录，则该Web应用的path属性是”app1”。如果名称不是app1而是ROOT，则该Web应用是虚拟主机默认的Web应用，此时path属性推导为””。reloadable属性指示tomcat是否在运行时监控在WEB-INF/classes和WEB-INF/lib目录下class文件的改动。如果值为true，那么当class文件改动时，会触发Web应用的重新加载。在开发环境下，reloadable设置为true便于调试；但是在生产环境中设置为true会给服务器带来性能压力，因此reloadable参数的默认值为false。下面来看自动部署时，xmlBase下的XML配置文件app1.xml的例子：1 &lt;Context docBase=”D:\\Program Files\\app1.war” reloadable=”true”/&gt;在该例子中，docBase位于Host的appBase目录之外；path属性没有指定，而是根据app1.xml自动推导为”app1”；由于是在开发环境下，因此reloadable设置为true，便于开发调试。自动部署举例最典型的自动部署，就是当我们安装完Tomcat后，$TOMCAT_HOME/webapps目录下有如下文件夹：当我们启动Tomcat后，可以使用http://localhost:8080/来访问Tomcat，其实访问的就是ROOT对应的Web应用；我们也可以通过http://localhost:8080/docs来访问docs应用，同理我们可以访问examples/host-manager/manager这几个Web应用。（3）server.xml中静态部署Web应用除了自动部署，我们也可以在server.xml中通过&lt;context&gt;元素静态部署Web应用。静态部署与自动部署是可以共存的。在实际应用中，并不推荐使用静态部署，因为server.xml 是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而自动部署可以在Tomcat运行时通过定期的扫描来实现，不需要重启服务器。server.xml中使用Context元素配置Web应用，Context元素应该位于Host元素中。举例如下：1 &lt;Context path=”/“ docBase=”D:\\Program Files \\app1.war” reloadable=”true”/&gt;docBase：静态部署时，docBase可以在appBase目录下，也可以不在；本例中，docBase不在appBase目录下。path：静态部署时，可以显式指定path属性，但是仍然受到了严格的限制：只有当自动部署完全关闭(deployOnStartup和autoDeploy都为false)或docBase不在appBase中时，才可以设置path属性。在本例中，docBase不在appBase中，因此path属性可以设置。reloadable属性的用法与自动部署时相同。四、核心组件的关联1、整体关系核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：Server元素在最顶层，代表整个Tomcat容器；一个Server元素中可以有一个或多个Service元素。Service在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；Connector接收请求，Engine处理请求。Engine、Host和Context都是容器，且 Engine包含Host，Host包含Context。每个Host组件代表Engine中的一个虚拟主机；每个Context组件代表在特定Host上运行的一个Web应用。2、如何确定请求由谁处理？当请求被发送到Tomcat所在的主机时，如何确定最终哪个Web应用来处理该请求呢？（1）根据协议和端口号选定Service和EngineService中的Connector组件可以接收特定端口的请求，因此，当Tomcat启动时，Service组件就会监听特定的端口。在第一部分的例子中，Catalina这个Service监听了8080端口（基于HTTP协议）和8009端口（基于AJP协议）。当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。通过在Server中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。（2）根据域名或IP地址选定HostService确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。在第一部分的例子中，由于只有一个Host（name属性为localhost），因此该Service/Engine的所有请求都交给该Host处理。（3）根据URI选定Context/Web应用这一点在Context一节有详细的说明：Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求，这里不再赘述。（4）举例以请求http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。3、如何配置多个服务通过在Server中配置多个Service服务，可以实现通过不同的端口号来访问同一台机器上部署的不同Web应用。在server.xml中配置多服务的方法非常简单，分为以下几步：（1）复制&lt;Service&gt;元素，放在当前&lt;Service&gt;后面。（2）修改端口号：根据需要监听的端口号修改&lt;Connector&gt;元素的port属性；必须确保该端口没有被其他进程占用，否则Tomcat启动时会报错，而无法通过该端口访问Web应用。以Win7为例，可以用如下方法找出某个端口是否被其他进程占用：netstat -aon|findstr “8081”发现8081端口被PID为2064的进程占用，tasklist |findstr “2064”发现该进程为FrameworkService.exe(这是McAfee杀毒软件的进程)。（3）修改Service和Engine的name属性（4）修改Host的appBase属性（如webapps2）（5）Web应用仍然使用自动部署（6）将要部署的Web应用(WAR包或应用目录)拷贝到新的appBase下。以第一部分的server.xml为例，多个Service的配置如下： 1 &lt;?xml version=’1.0’ encoding=’utf-8’?&gt; 2 &lt;Server port=”8005” shutdown=”SHUTDOWN”&gt; 3 &lt;Listener className=”org.apache.catalina.startup.VersionLoggerListener” /&gt; 4 &lt;Listener className=”org.apache.catalina.core.AprLifecycleListener” SSLEngine=”on” /&gt; 5 &lt;Listener className=”org.apache.catalina.core.JasperListener” /&gt; 6 &lt;Listener className=”org.apache.catalina.core.JreMemoryLeakPreventionListener” /&gt; 7 &lt;Listener className=”org.apache.catalina.mbeans.GlobalResourcesLifecycleListener” /&gt; 8 &lt;Listener className=”org.apache.catalina.core.ThreadLocalLeakPreventionListener” /&gt; 910 &lt;GlobalNamingResources&gt;11 &lt;Resource name=”UserDatabase” auth=”Container” type=”org.apache.catalina.UserDatabase” description=”User database that can be updated and saved” factory=”org.apache.catalina.users.MemoryUserDatabaseFactory” pathname=”conf/tomcat-users.xml” /&gt;12 &lt;/GlobalNamingResources&gt;1314 &lt;Service name=”Catalina”&gt;15 &lt;Connector port=”8080” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt;16 &lt;Connector port=”8009” protocol=”AJP/1.3” redirectPort=”8443” /&gt;17 &lt;Engine name=”Catalina” defaultHost=”localhost”&gt;18 &lt;Realm className=”org.apache.catalina.realm.LockOutRealm”&gt;19 &lt;Realm className=”org.apache.catalina.realm.UserDatabaseRealm”20 resourceName=”UserDatabase”/&gt;21 &lt;/Realm&gt;2223 &lt;Host name=”localhost” appBase=”/opt/project/webapps” unpackWARs=”true” autoDeploy=”true”&gt;24 &lt;Valve className=”org.apache.catalina.valves.AccessLogValve” directory=”logs” prefix=”localhost_access_log.” suffix=”.txt” pattern=”%h %l %u %t &amp;quot;%r&amp;quot; %s %b” /&gt;25 &lt;/Host&gt;26 &lt;/Engine&gt;27 &lt;/Service&gt;2829 &lt;Service name=”Catalina2”&gt;30 &lt;Connector port=”8084” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt;31 &lt;Connector port=”8010” protocol=”AJP/1.3” redirectPort=”8443” /&gt;32 &lt;Engine name=”Catalina2” defaultHost=”localhost”&gt;33 &lt;Realm className=”org.apache.catalina.realm.LockOutRealm”&gt;34 &lt;Realm className=”org.apache.catalina.realm.UserDatabaseRealm”35 resourceName=”UserDatabase”/&gt;36 &lt;/Realm&gt;3738 &lt;Host name=”localhost” appBase=”/opt/project/webapps2” unpackWARs=”true” autoDeploy=”true”&gt;39 &lt;Valve className=”org.apache.catalina.valves.AccessLogValve” directory=”logs” prefix=”localhost_access_log.” suffix=”.txt” pattern=”%h %l %u %t &amp;quot;%r&amp;quot; %s %b” /&gt;40 &lt;/Host&gt;41 &lt;/Engine&gt;42 &lt;/Service&gt;43 &lt;/Server&gt;再将原webapps下的docs目录拷贝到webapps2中，则通过如下两个接口都可以访问docs应用：http://localhost:8080/docs/http://localhost:8084/docs/五、其他组件除核心组件外，server.xml中还可以配置很多其他组件。下面只介绍第一部分例子中出现的组件，如果要了解更多内容，可以查看Tomcat官方文档。1、Listener1 &lt;Listener className=”org.apache.catalina.startup.VersionLoggerListener” /&gt;2 &lt;Listener className=”org.apache.catalina.core.AprLifecycleListener” SSLEngine=”on” /&gt;3 &lt;Listener className=”org.apache.catalina.core.JasperListener” /&gt;4 &lt;Listener className=”org.apache.catalina.core.JreMemoryLeakPreventionListener” /&gt;5 &lt;Listener className=”org.apache.catalina.mbeans.GlobalResourcesLifecycleListener” /&gt;6 &lt;Listener className=”org.apache.catalina.core.ThreadLocalLeakPreventionListener” /&gt;Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。监听器可以在Server、Engine、Host或Context中，本例中的监听器都是在Server中。实际上，本例中定义的6个监听器，都只能存在于Server组件中。监听器不允许内嵌其他组件。监听器需要配置的最重要的属性是className，该属性规定了监听器的具体实现类，该类必须实现了org.apache.catalina.LifecycleListener接口。下面依次介绍例子中配置的监听器：VersionLoggerListener：当Tomcat启动时，该监听器记录Tomcat、Java和操作系统的信息。该监听器必须是配置的第一个监听器。AprLifecycleListener：Tomcat启动时，检查APR库，如果存在则加载。APR，即Apache Portable Runtime，是Apache可移植运行库，可以实现高可扩展性、高性能，以及与本地服务器技术更好的集成。JasperListener：在Web应用启动之前初始化Jasper，Jasper是JSP引擎，把JVM不认识的JSP文件解析成java文件，然后编译成class文件供JVM使用。JreMemoryLeakPreventionListener：与类加载器导致的内存泄露有关。GlobalResourcesLifecycleListener：通过该监听器，初始化&lt; GlobalNamingResources&gt;标签中定义的全局JNDI资源；如果没有该监听器，任何全局资源都不能使用。&lt; GlobalNamingResources&gt;将在后文介绍。ThreadLocalLeakPreventionListener：当Web应用因thread-local导致的内存泄露而要停止时，该监听器会触发线程池中线程的更新。当线程执行完任务被收回线程池时，活跃线程会一个一个的更新。只有当Web应用(即Context元素)的renewThreadsWhenStoppingContext属性设置为true时，该监听器才有效。2、GlobalNamingResources与Realm第一部分的例子中，Engine组件下定义了Realm组件：1 &lt;Realm className=”org.apache.catalina.realm.LockOutRealm”&gt;2 &lt;Realm className=”org.apache.catalina.realm.UserDatabaseRealm”3 resourceName=”UserDatabase”/&gt;4 &lt;/Realm&gt;Realm，可以把它理解成“域”；Realm提供了一种用户密码与web应用的映射关系，从而达到角色安全管理的作用。在本例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配置：1 &lt;GlobalNamingResources&gt;2 &lt;Resource name=”UserDatabase” auth=”Container” type=”org.apache.catalina.UserDatabase” description=”User database that can be updated and saved” factory=”org.apache.catalina.users.MemoryUserDatabaseFactory” pathname=”conf/tomcat-users.xml” /&gt;3 &lt;/GlobalNamingResources&gt;GlobalNamingResources元素定义了全局资源，通过配置可以看出，该配置是通过读取$TOMCAT_HOME/ conf/tomcat-users.xml实现的。关于Tomcat域管理的更多内容，可以参考：Realm域管理3、Valve在第一部分的例子中，Host元素内定义了Valve组件：1 &lt;Valve className=”org.apache.catalina.valves.AccessLogValve” directory=”logs” prefix=”localhost_access_log.” suffix=”.txt” pattern=”%h %l %u %t &amp;quot;%r&amp;quot; %s %b” /&gt;单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。不同的Valve有不同的特性，下面介绍一下本例中出现的AccessLogValve。AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve可以与Engine、Host或Context关联；在本例中，只有一个Engine，Engine下只有一个Host，Host下只有一个Context，因此AccessLogValve放在三个容器下的作用其实是类似的。本例的AccessLogValve属性的配置，使用的是默认的配置；下面介绍AccessLogValve中各个属性的作用：（1）className：规定了Valve的类型，是最重要的属性；本例中，通过该属性规定了这是一个AccessLogValve。（2）directory：指定日志存储的位置，本例中，日志存储在$TOMCAT_HOME/logs目录下。（3）prefix：指定了日志文件的前缀。（4）suffix：指定了日志文件的后缀。通过directory、prefix和suffix的配置，在$TOMCAT_HOME/logs目录下，可以看到如下所示的日志文件。（5）pattern：指定记录日志的格式，本例中各项的含义如下：%h：远程主机名或IP地址；如果有nginx等反向代理服务器进行请求分发，该主机名/IP地址代表的是nginx，否则代表的是客户端。后面远程的含义与之类似，不再解释。%l：远程逻辑用户名，一律是”-”，可以忽略。%u：授权的远程用户名，如果没有，则是”-”。%t：访问的时间。%r：请求的第一行，即请求方法(get/post等)、uri、及协议。%s：响应状态，200,404等等。%b：响应的数据量，不包括请求头，如果为0，则是””-。例如，下面是访问日志中的一条记录pattern的配置中，除了上述各项，还有一个非常常用的选项是%D，含义是请求处理的时间(单位是毫秒)，对于统计分析请求的处理速度帮助很大。开发人员可以充分利用访问日志，来分析问题、优化应用。例如，分析访问日志中各个接口被访问的比例，不仅可以为需求和运营人员提供数据支持，还可以使自己的优化有的放矢；分析访问日志中各个请求的响应状态码，可以知道服务器请求的成功率，并找出有问题的请求；分析访问日志中各个请求的响应时间，可以找出慢请求，并根据需要进行响应时间的优化。六、参考文献Tomcat官方文档《How Tomcat Works》《深入分析Java Web技术内幕》Tomcat 6 —— Realm域管理Tomcat Port 8009 与AJP13协议使用Jasper引擎解析JSP","categories":[{"name":"应用服务器","slug":"应用服务器","permalink":"http://www.note4u.cn/categories/应用服务器/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://www.note4u.cn/tags/tomcat/"}]},{"title":"leetcode-21-java","slug":"algorithm/leetcode-21-java","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/06/10/algorithm/leetcode-21-java/","link":"","permalink":"http://www.note4u.cn/2019/06/10/algorithm/leetcode-21-java/","excerpt":"问题:21. Merge Two Sorted Lists1234567Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4","text":"问题:21. Merge Two Sorted Lists1234567Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 leetcode地址 123456789101112131415161718192021222324252627282930313233/** * Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 * Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 * @param l1 * @param l2 * @return */public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode cursor = dummy; while (null != l1 || null != l2) &#123; if ((null != l1 &amp;&amp; null != l2 &amp;&amp; l1.val &lt;= l2.val) || (null != l1 &amp;&amp; null == l2)) &#123; cursor.next = l1; l1 = l1.next; &#125; else &#123; cursor.next = l2; l2 = l2.next; &#125; cursor = cursor.next; &#125; return dummy.next;&#125;private static class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-20-java","slug":"algorithm/leetcode-20-java","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/06/06/algorithm/leetcode-20-java/","link":"","permalink":"http://www.note4u.cn/2019/06/06/algorithm/leetcode-20-java/","excerpt":"问题:20. Valid Parentheses12345678Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;&#123;&apos;, &apos;&#125;&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.","text":"问题:20. Valid Parentheses12345678Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;&#123;&apos;, &apos;&#125;&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid. leetcode地址 123456789101112131415161718192021222324252627282930313233343536 public static boolean isValid(String s) &#123; if (&quot;&quot;.equals(s)) &#123; return true; &#125; if (s.length()%2 != 0) &#123; return false; &#125; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for (char c : chars) &#123; if (stack.isEmpty()) &#123; stack.push(c); continue; &#125; if (isMath(stack.peek(), c)) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; return stack.isEmpty(); &#125; private static boolean isMath(char c1, char c2) &#123;// if (c1 == &apos;(&apos;) &#123;// return c2 == &apos;)&apos;;// &#125; else if (c1 == &apos;[&apos;) &#123;// return c2 == &apos;]&apos;;// &#125; else if (c1 == &apos;&#123;&apos;) &#123;// return c2 == &apos;&#125;&apos;;// &#125; int sum = c1 + c2; return sum == 81 || sum == 184 || sum == 248; &#125; 一些IDE编辑器的语法校验也是通过压栈、弹栈的方式判定括号是否合法","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-19-java","slug":"algorithm/leetcode-19-java","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/06/05/algorithm/leetcode-19-java/","link":"","permalink":"http://www.note4u.cn/2019/06/05/algorithm/leetcode-19-java/","excerpt":"问题:19. Remove Nth Node From End of List1234567Given a linked list, remove the n-th node from the end of list and return its head.Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.","text":"问题:19. Remove Nth Node From End of List1234567Given a linked list, remove the n-th node from the end of list and return its head.Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. leetcode地址 12345678910111213141516171819202122public ListNode removeNthFromEnd(ListNode head, int n) &#123; //创建起始 ListNode start = new ListNode(0); start.next = head; //创建游标 ListNode cursor1 = start; ListNode cursor2 = start; while (n &gt; 0) &#123; cursor1 = cursor1.next; n --; &#125; while (cursor1.next != null) &#123; cursor1 = cursor1.next; cursor2 = cursor2.next; &#125; cursor2.next = cursor2.next.next; return start.next;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-18-java","slug":"algorithm/leetcode-18-java","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/06/05/algorithm/leetcode-18-java/","link":"","permalink":"http://www.note4u.cn/2019/06/05/algorithm/leetcode-18-java/","excerpt":"问题:18. 4Sum1234567891011121314151617Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note:The solution set must not contain duplicate quadruplets.Example:Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]","text":"问题:18. 4Sum1234567891011121314151617Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note:The solution set must not contain duplicate quadruplets.Example:Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] leetcode地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (null == nums || nums.length &lt; 4) &#123; return list; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int threeTarget = target - nums[i]; threeSum(nums[i], threeTarget, i+1, nums, list); &#125; return list;&#125;public static void threeSum(int firt, int target, int left, int[] nums, List&lt;List&lt;Integer&gt;&gt; list) &#123; for (int i = left; i &lt; nums.length; i++) &#123; if (i &gt; left &amp;&amp; nums[i - 1] == nums[i]) &#123; continue; &#125; int twoTarget = target -nums[i]; twoSum(firt, nums[i], twoTarget, i + 1, nums.length - 1, nums, list); &#125;&#125;private static void twoSum(int first, int second, int target, int left, int right, int[] nums, List&lt;List&lt;Integer&gt;&gt; list) &#123; while (left &lt; right) &#123; int tmp = nums[left] + nums[right]; if (tmp == target) &#123; list.add(Arrays.asList(first, second, nums[left], nums[right])); left ++; right --; while (left &lt; right &amp;&amp; nums[left - 1] == nums[left]) &#123; left ++; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; right --; &#125; &#125; else if (tmp &gt; target) &#123; right --; &#125; else if (tmp &lt; target) &#123; left ++; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-17-java","slug":"algorithm/leetcode-17-java","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/06/04/algorithm/leetcode-17-java/","link":"","permalink":"http://www.note4u.cn/2019/06/04/algorithm/leetcode-17-java/","excerpt":"问题:17. Letter Combinations of a Phone Number123456789Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Example:Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].","text":"问题:17. Letter Combinations of a Phone Number123456789Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Example:Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839private static List&lt;String&gt; baseList = new ArrayList&lt;String&gt;()&#123;&#123; add(null); add(null); add(&quot;abc&quot;); add(&quot;def&quot;); add(&quot;ghi&quot;); add(&quot;jkl&quot;); add(&quot;mno&quot;); add(&quot;pqrs&quot;); add(&quot;tuv&quot;); add(&quot;wxyz&quot;);&#125;&#125;;public static List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (null == digits || digits.length() == 0) &#123; return list; &#125; for (int i = 0; i &lt; digits.length(); i++) &#123; char[] chars = baseList.get(Integer.parseInt(String.valueOf(digits.charAt(i)))).toCharArray(); if (i == 0) &#123; for (char c : chars) &#123; list.add(String.valueOf(c)); &#125; &#125; else &#123; int len = list.size(); for (int j = 0; j &lt; len; j++) &#123; for (char c : chars) &#123; list.add(list.get(j) + c); &#125; &#125; list = list.subList(len, list.size()); &#125; &#125; return list;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-16-java","slug":"algorithm/leetcode-16-java","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/06/04/algorithm/leetcode-16-java/","link":"","permalink":"http://www.note4u.cn/2019/06/04/algorithm/leetcode-16-java/","excerpt":"问题:16. 3Sum Closest12345678Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.Example:Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).","text":"问题:16. 3Sum Closest12345678Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.Example:Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). leetcode地址 1234567891011121314151617181920212223242526272829public static int threeSumClosest(int[] nums, int target) &#123; if (null == nums || nums.length &lt; 3) &#123; return 0; &#125; //先进行排序 Arrays.sort(nums); int result = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int twoTarget = target - nums[i]; int left = i + 1; int right = nums.length - 1; while (left &lt; right) &#123; int real = nums[left] + nums[right]; if (real == twoTarget) &#123; return target; &#125; else if (real &gt; twoTarget) &#123; right --; &#125; else if (real &lt; twoTarget) &#123; left ++; &#125; result = Math.abs(target - nums[i] - real) &lt; Math.abs(target - result) ? (nums[i] + real) : result; &#125; &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-15-java","slug":"algorithm/leetcode-15-java","date":"un11fin11","updated":"un22fin22","comments":true,"path":"2019/06/03/algorithm/leetcode-15-java/","link":"","permalink":"http://www.note4u.cn/2019/06/03/algorithm/leetcode-15-java/","excerpt":"问题:15. 3Sum123456789101112131415Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]]","text":"问题:15. 3Sum123456789101112131415Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] leetcode地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (null == nums || nums.length &lt; 3) &#123; return list; &#125; //jdk自带的快速排序 //Arrays.sort(nums); insertSort(nums); int right = nums.length - 1; for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; twoSum(list, nums, -1 * nums[i], i + 1, right); &#125; return list;&#125;private static void twoSum(List&lt;List&lt;Integer&gt;&gt; list, int[] nums, int target, int left , int right) &#123; while (left &lt; right) &#123; int tmp = nums[left] + nums[right]; if (tmp == target) &#123; list.add(Arrays.asList(-target, nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123; left ++; &#125; while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123; right --; &#125; left ++; right--; &#125; else if (tmp &gt; target) &#123; right --; &#125; else if (tmp &lt; target) &#123; left ++; &#125; &#125;&#125;//插入排序private static void insertSort(int[] arrs) &#123; for (int i = 1; i &lt; arrs.length; i++) &#123; int index = i; int cur = arrs[index]; while (index &gt; 0) &#123; if (cur &lt; arrs[index - 1]) &#123; arrs[index] = arrs[index - 1]; index --; &#125; else &#123; break; &#125; &#125; arrs[index] = cur; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-14-java","slug":"algorithm/leetcode-14-java","date":"un44fin44","updated":"un22fin22","comments":true,"path":"2019/05/30/algorithm/leetcode-14-java/","link":"","permalink":"http://www.note4u.cn/2019/05/30/algorithm/leetcode-14-java/","excerpt":"问题:14. Longest Common Prefix12345678910111213Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string &quot;&quot;.Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.","text":"问题:14. Longest Common Prefix12345678910111213Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string &quot;&quot;.Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. leetcode地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Leetcode14 &#123; public static String longestCommonPrefix(String[] strs) &#123; if (null == strs || strs.length == 0) &#123; return &quot;&quot;; &#125; if (strs.length == 1) &#123; return strs[0]; &#125; String maxSub = sub(strs[0], strs[1]); if (&quot;&quot;.equals(maxSub)) &#123; return &quot;&quot;; &#125; for (int i = 1; i &lt; strs.length; i++) &#123; maxSub = sub(maxSub, strs[i]); if (&quot;&quot;.equals(maxSub)) &#123; return &quot;&quot;; &#125; &#125; return maxSub; &#125; /** * 获取公共前缀 * @param s1 * @param s2 * @return */ private static String sub(String s1, String s2) &#123; int len = Math.min(s1.length(), s2.length()); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; len; i++) &#123; if (s1.charAt(i) == s2.charAt(i)) &#123; sb.append(s1.charAt(i)); continue; &#125; break; &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; System.out.println(longestCommonPrefix(new String[] &#123;&quot;aca&quot;,&quot;cba&quot;&#125;)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-13-java","slug":"algorithm/leetcode-13-java","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/05/30/algorithm/leetcode-13-java/","link":"","permalink":"http://www.note4u.cn/2019/05/30/algorithm/leetcode-13-java/","excerpt":"问题:13.Roman to Integer12345678910Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.Example 1:Input: &quot;III&quot;Output: 3Example 2:Input: &quot;IV&quot;Output: 4","text":"问题:13.Roman to Integer12345678910Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.Example 1:Input: &quot;III&quot;Output: 3Example 2:Input: &quot;IV&quot;Output: 4 leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; private static Map&lt;String, Integer&gt; doubleMap = new HashMap&lt;String, Integer&gt;() &#123;&#123; put(&quot;CM&quot;, 900); put(&quot;CD&quot;, 400); put(&quot;XC&quot;, 90); put(&quot;XL&quot;, 40); put(&quot;IX&quot;, 9); put(&quot;IV&quot;, 4); &#125;&#125;; private static Map&lt;String, Integer&gt; singleMap = new HashMap&lt;String, Integer&gt;() &#123;&#123; put(&quot;M&quot;, 1000); put(&quot;D&quot;, 500); put(&quot;C&quot;, 100); put(&quot;L&quot;, 50); put(&quot;X&quot;, 10); put(&quot;V&quot;, 5); put(&quot;I&quot;, 1); &#125;&#125;; public static int romanToInt(String s) &#123; if (null == s || s.length() == 0) &#123; return 0; &#125; int sum = 0; int index = 0; while (index &lt; s.length()) &#123; int end = index + 2; if (end &lt;= s.length()) &#123; String douStr = s.substring(index, end); if (null != doubleMap.get(douStr)) &#123; sum += doubleMap.get(douStr); index += 2; continue; &#125; &#125; end = index + 1; String douStr = s.substring(index, end); if (null != singleMap.get(douStr)) &#123; sum += singleMap.get(douStr); index += 1; continue; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-12-java","slug":"algorithm/leetcode-12-java","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/05/29/algorithm/leetcode-12-java/","link":"","permalink":"http://www.note4u.cn/2019/05/29/algorithm/leetcode-12-java/","excerpt":"问题:12. Integer to Roman123456789101112Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one&apos;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II","text":"问题:12. Integer to Roman123456789101112Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one&apos;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; private static List&lt;Point&gt; list = new ArrayList&lt;Point&gt;()&#123;&#123; add(new Point(1000, &quot;M&quot;)); add(new Point(900, &quot;CM&quot;)); add(new Point(500, &quot;D&quot;)); add(new Point(400, &quot;CD&quot;)); add(new Point(100, &quot;C&quot;)); add(new Point(90, &quot;XC&quot;)); add(new Point(50, &quot;L&quot;)); add(new Point(40, &quot;XL&quot;)); add(new Point(10, &quot;X&quot;)); add(new Point(9, &quot;IX&quot;)); add(new Point(5, &quot;V&quot;)); add(new Point(4, &quot;IV&quot;)); add(new Point(1, &quot;I&quot;)); &#125; &#125;; public static String intToRoman(int num) &#123; int index = 0; StringBuffer sb = new StringBuffer(); while (num != 0) &#123; Point point = list.get(index); if (num - point.getBase() &gt;= 0) &#123; sb.append(point.getDesc()); num -= point.getBase(); &#125; else &#123; index ++; &#125; &#125; return sb.toString(); &#125; private static class Point &#123; private Integer base; private String desc; private Point(Integer base, String desc) &#123; this.base = base; this.desc = desc; &#125; public Integer getBase() &#123; return base; &#125; public void setBase(Integer base) &#123; this.base = base; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-11-java","slug":"algorithm/leetcode-11-java","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/05/28/algorithm/leetcode-11-java/","link":"","permalink":"http://www.note4u.cn/2019/05/28/algorithm/leetcode-11-java/","excerpt":"问题:11. Container With Most Water123Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.","text":"问题:11. Container With Most Water123Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. leetcode详细地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 时间复杂度0(n^2) * @param height * @return */ public static int maxAreaN2(int[] height) &#123; int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; //取最小的高度 int maxHeight = height[i] &lt; height[j] ? height[i] : height[j]; int tmpArea = maxHeight * (j - i); maxArea = maxArea &lt; tmpArea ? tmpArea : maxArea; &#125; &#125; return maxArea; &#125; /** * 时间复杂度0(n) * @param height * @return */ public static int maxAreaN(int[] height) &#123; int left = 0; int right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; int tmp = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, tmp); if (height[left] &lt; height[right]) &#123; left ++; &#125; else &#123; right --; &#125; &#125; return maxArea; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-10-java","slug":"algorithm/leetcode-10-java","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/05/28/algorithm/leetcode-10-java/","link":"","permalink":"http://www.note4u.cn/2019/05/28/algorithm/leetcode-10-java/","excerpt":"","text":"12不会，想半天， 没想出来换下一个","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-9-java","slug":"algorithm/leetcode-9-java","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/05/27/algorithm/leetcode-9-java/","link":"","permalink":"http://www.note4u.cn/2019/05/27/algorithm/leetcode-9-java/","excerpt":"问题9:Palindrome Number1234567891011Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.","text":"问题9:Palindrome Number1234567891011Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. leetcode地址 1234567891011121314public static boolean isPalindrome(int x) &#123; if (x &lt; 0) &#123; return false; &#125; char[] chars = (&quot;&quot; + x).toCharArray(); for (int i = 0; i &lt; chars.length / 2; i++) &#123; if (chars[i] != chars[chars.length - 1 - i]) &#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-8-java","slug":"algorithm/leetcode-8-java","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/05/26/algorithm/leetcode-8-java/","link":"","permalink":"http://www.note4u.cn/2019/05/26/algorithm/leetcode-8-java/","excerpt":"问题8:String to Integer (atoi)1234567891011121314Implement atoi which converts a string to an integer.The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42.","text":"问题8:String to Integer (atoi)1234567891011121314Implement atoi which converts a string to an integer.The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. leetcode地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 1.判断首字符是否是符号, 获取迭代的起始位置 * 2.判断是否是负号 * 3.上次迭代的结果数乘以10 然后加上 对应字符数字乘以符号基础数(1 or -1) * * @param str * @return */ public static int myAtoi(String str) &#123; if (null == str ) &#123; return 0; &#125; str = str.trim(); if (str.length() == 0) &#123; return 0; &#125; char firstChar = str.charAt(0); //是否符号 boolean isSign = false; //是否负号 boolean isNeg = false; if ((isNeg = (&apos;-&apos; == firstChar)) || &apos;+&apos; == firstChar) &#123; isSign = true; &#125; long result = 0; //起始位置 int index = isSign ? 1 : 0; //基础数 int neg = isNeg ? -1 : 1; char[] chars = str.toCharArray(); for (int i = index; i &lt; chars.length; i++) &#123; char tmp = chars[i]; if (tmp &lt; 48 || tmp &gt; 57) &#123; break; &#125; result = result * 10 + Long.valueOf(String.valueOf(tmp)) * neg; if (result &gt; Integer.MAX_VALUE) &#123; return Integer.MAX_VALUE; &#125; if (result &lt; Integer.MIN_VALUE) &#123; return Integer.MIN_VALUE; &#125; &#125; return (int) result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-7-java","slug":"algorithm/leetcode-7-java","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2019/05/25/algorithm/leetcode-7-java/","link":"","permalink":"http://www.note4u.cn/2019/05/25/algorithm/leetcode-7-java/","excerpt":"问题7:Reverse Integer12345678910111213Given a 32-bit signed integer, reverse digits of an integer.Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21","text":"问题7:Reverse Integer12345678910111213Given a 32-bit signed integer, reverse digits of an integer.Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 leetcode详细地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//转化成字符串-&gt;cha[], 进行位置互换 public static int reverse(int x) &#123; boolean isNeg = x &lt; 0; String str = &quot;&quot; + Math.abs(x); char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length / 2; i++) &#123; char tmp = chars[i]; chars[i] = chars[chars.length - 1 - i]; chars[chars.length - 1 - i] = tmp; &#125; long value = Long.valueOf(new String(chars)); if (isNeg) &#123; value = -value; &#125; if (value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE) &#123; return 0; &#125; return (int) value; &#125;``` ``` /** * x%10 获取最小位的数值 * 同时 x/10获取到下一进位的数据. * 循环迭代，然后将每次获取的最小进位 *10, 然后加和 * * ps: 因为每次只对数据进行进位加和， 或者减位操作 * 负数的加和还是负数 * * 所以不用对符号处理。 * @param x * @return */ public static int reverse(int x) &#123; long result = 0; while (x != 0) &#123; result = result * 10 + x % 10; if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; //溢出 return 0; &#125; //x 缩小一个进位 x = x/10; &#125; return (int) result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-6-java","slug":"algorithm/leetcode-6-java","date":"un44fin44","updated":"un11fin11","comments":true,"path":"2019/05/23/algorithm/leetcode-6-java/","link":"","permalink":"http://www.note4u.cn/2019/05/23/algorithm/leetcode-6-java/","excerpt":"问题6:ZigZag Conversion123456789101112131415161718192021222324The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows);Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I","text":"问题6:ZigZag Conversion123456789101112131415161718192021222324The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows);Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I leetcode详情地址 12345678910111213141516171819202122232425262728293031323334353637383940414243441.我的解题思路:我看到这个的第一反应，就是将字符串转化为二维数组, 然后迭代拼接字符串 public static String convert(String s, int numRows) &#123; if (numRows &lt;= 1) &#123; return s; &#125; int len = s.length(); int cell = cell(len, numRows); char[][] result = new char[numRows][cell]; for (int i = 0; i &lt; len; i++) &#123; int row = row(i, numRows); int cel = cell(i + 1, numRows) - 1; result[row][cel] = s.charAt(i); &#125; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; result.length; i++) &#123; char[] arr = result[i]; for (int j = 0; j &lt; arr.length; j++) &#123; sb.append(arr[j]); &#125; &#125; return sb.toString(); &#125; private static int row(int index, int num) &#123; int mod = index % (num + num - 2); return mod &lt; num ? mod : Math.abs(mod - num - num + 2); &#125; private static int cell(int len , int mum) &#123; int cellMod = len % (mum + mum - 2); int cell = len / (mum + mum - 2); if (0 == cellMod) &#123; cell = cell * (mum - 2 + 1); &#125; else &#123; cell = cell * (mum - 2 + 1) + ((cellMod - mum) &gt; 0 ? (1 + cellMod - mum) : 1); &#125; return cell; &#125; 123456789101112131415161718192021222324252627282930313233342.提交leetcode发现，时间复杂度过去不。重新分析这个问题, 其实只要考虑每个字符行所在行的位置即可因为是对整个字符串进行迭代， 即每行的子串本身已有顺序，public static String convert(String s, int numRows) &#123; if (numRows &lt;= 1) &#123; return s; &#125; Map&lt;Integer, StringBuffer&gt; params = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; int row = row(i, numRows); StringBuffer sb = params.get(row); if (null == sb) &#123; sb = new StringBuffer(); params.put(row, sb); &#125; sb.append(s.charAt(i)); &#125; StringBuffer sb = new StringBuffer(); for (Map.Entry&lt;Integer, StringBuffer&gt; entry : params.entrySet()) &#123; sb.append(entry.getValue()); &#125; return sb.toString(); &#125; //根据下标获取该字符转化之后所在的行 private static int row(int index, int num) &#123; //一个标准子串对应的长度 int mod = (num + num - 2); int modResult = index % mod; return modResult &lt; num ? modResult : Math.abs(modResult - mod); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"动态规划","slug":"algorithm/动态规划","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2019/05/23/algorithm/动态规划/","link":"","permalink":"http://www.note4u.cn/2019/05/23/algorithm/动态规划/","excerpt":"问题一:求斐波那契数列第N项的值12345678910111213141516171819202122232425/** * 1 1 2 3 5 8 13 21 34 55 * 斐波拉契数列 * @param n 求第N项的值 * @return */ public static int fibonacci(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; int[] result = new int[n]; result[0] = 1; result[1] = 1; for (int i = 2; i &lt; n; i++) &#123; int next = result[i - 1] + result[i - 2]; result[i] = next; &#125; return result[n - 1]; &#125;","text":"问题一:求斐波那契数列第N项的值12345678910111213141516171819202122232425/** * 1 1 2 3 5 8 13 21 34 55 * 斐波拉契数列 * @param n 求第N项的值 * @return */ public static int fibonacci(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; int[] result = new int[n]; result[0] = 1; result[1] = 1; for (int i = 2; i &lt; n; i++) &#123; int next = result[i - 1] + result[i - 2]; result[i] = next; &#125; return result[n - 1]; &#125; 问题二:上台阶问题12345678910111213141516171819202122232425262728293031323334/** * 有一楼梯共n级，刚开始时你在第0级，若每次只能跨上一级或二级，要走上第n级，共有多少走法？ * @param n * 假设第n阶共有f(n)中走法, 同理第n-1 共有 f(n-1), 第n-2共有 f(n-2) * 因为n-1和n-2的终点不一样， 所有f(n-1)和f(n-2)没有重复走法 * 故f(n-1)向上走一步, f(n-2)向上走2步, 加和即是f(n)的走法 * * 转移方程 f(n) = f(n-1) + f(n-2); * * ps： */ public static int stepLow(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; int[] result = new int[n]; //一级台阶 result[0] = 1; //二级台阶 result[1] = 2; for (int i = 2; i &lt; n; i++) &#123; int next = result[i - 1] + result[i - 2]; result[i] = next; &#125; return result[n - 1]; &#125; 问题三:上台阶问题-复杂版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 一个台阶总共有n级，如果一次可以跳1级，也可以跳2级......它也可以跳上n级。此时一只青蛙跳上一个n级的台阶总共有多少种跳法？ * 假设n阶台阶共有f(n)种方法 * 则n-1阶有f(n-1) * n-2有f(n-2) * n-3有f(n-3) * ... * 1 有 1种 * 因为可以任意跳 * 故转移方程为: * f(n) = f(n-1) + f(n-2 + f(n-3) + ... + f(1) + 1; * 将问题二中的数据迭代家 * @param n * @return */public static int stepHigh(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; int[] result = new int[n + 1]; //从0 开始，不容易错 result[0] = 0; //一级台阶 result[1] = 1; //二级台阶 result[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; int index = i - 1; int next = 0; while (index &gt; 0) &#123; next += result[index]; index --; &#125; result[i] = next + 1; &#125; return result[n];&#125;因为 f(n) = f(n-1) + f(n-2 + f(n-3) + ... + 1 (1)则 f(n-1) = f(n-2) + f(n-3) + ... + 1 (2)(1) - (2) 化简得:f(n) = 2f(n-1);递归实现：public static int stepRecursion(int n) &#123; if (n == 1) &#123; return 1; &#125; return 2 * stepRecursion(n - 1);&#125; 问题4:青蛙抓虫子12345678910111213141516171819202122232425262728293031323334353637383940/** * 一只青蛙，想要捕食距离它M米处的一只昆虫。 * 已知青蛙的蛙跳范围为[1, N]之间，单位米（每次蛙跳距离为整数，即[1,N]之间的整数）。青蛙在0的位置，求青蛙跳到M的位置吃到昆虫的方案数。 * @param n 最大步长 * @param m 距离 */ public static int frodGrabBug(int n, int m) &#123; // m &lt; n, -----m---n // 蛙子最远一次能跳到m, 即从0-m(任意步长) if (m &lt; n) &#123; return stepRecursion(m); &#125; else &#123; //m &gt; n, 设点\u001b i &gt;=n &amp;&amp; i &lt;= m 如：----n(4)--i--(m) // f(m) = f(m-1) + f(m-2) + f(m-3) + ... + f(m-n); //可以拆成2部分 //1. 距离 i &lt;= n, 则问题变成问题三（n级台阶，可以跳[1,n]次，有多少种跳法） //2. i &gt; n &amp;&amp; i &lt;= m 则 f(i) = f(m - i) + f(m -i -1) + ... + f(m-n) //存储结果 int[] result = new int[m + 1]; result[0] = 0; result[1] = 1; for (int i = 2; i &lt;= m; i++) &#123; int index = i - 1; int sum = 0; while (index &gt;= i - n &amp;&amp; index &gt; 0) &#123; sum += result[index]; index --; &#125; //m属于[1,n], 包含一次直接跳到n if (i &lt;= n) &#123; sum += 1; &#125; result[i] = sum; &#125; return result[m]; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://www.note4u.cn/categories/算法/动态规划/"}],"tags":[{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.note4u.cn/tags/dynamic-programming/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.note4u.cn/tags/动态规划/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.note4u.cn/tags/algorithm/"}]},{"title":"leetcode-5-java","slug":"algorithm/leetcode-5-java","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2019/05/21/algorithm/leetcode-5-java/","link":"","permalink":"http://www.note4u.cn/2019/05/21/algorithm/leetcode-5-java/","excerpt":"问题5:Longest Palindromic Substring1234567891011给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;","text":"问题5:Longest Palindromic Substring1234567891011给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot; 问题详情地址: [leetcode地址]解法一: 直接迭代循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 直接迭代判断每个子串是否是回文。 * 从每个字符向后迭代,时间复杂度0(n^2) * 判断每个子串是否是回文,时间复杂度O(n) * 该实现整个时间复杂度0(n^3) * @param str * @return */ public static String longestPalindromeN3(String str) &#123; if (null == str) &#123; return &quot;&quot;; &#125; if (str.length() == 1) &#123; return str; &#125; //回文最长值 int maxLen = 0; //当前最长值的下表索引值 int index = 0; for (int i = 0; i &lt; str.length(); i++) &#123; for (int j = i + 1; j &lt;= str.length(); j++) &#123; String tmp = str.substring(i, j); if (isPalindrome(tmp)) &#123; if (j - i &gt; maxLen) &#123; maxLen = j - i; index = i; &#125; &#125; &#125; &#125; return str.substring(index, index + maxLen); &#125; /** * 判断是否是回文 * @param str * @return */ private static boolean isPalindrome(String str) &#123; int len = str.length(); for (int i = 0; i &lt; len / 2; i++) &#123; if (str.charAt(i) != str.charAt(len - i - 1)) &#123; return false; &#125; &#125; return true; &#125; 解法二:中心扩展法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 中心扩展法 * 从某一点向2边扩展 * 时间复杂度0(n^2) * 则arr[i] == arr[i+1] (长度为偶数） * 或者 arr[i-1] = arr[i+1] (长度为奇数） * @param str * @return */ public static String longestPalindromeN2(String str) &#123; if (null == str || str.length() &lt;= 0) &#123; return null; &#125; if (str.length() == 1) &#123; return str; &#125; //索引位置 int index = 0; //最大回文文场长度 int maxLen = 0; for (int i = 0; i &lt; str.length(); i++) &#123; //回文为奇数 int len1 = maxLen(str, i, i); //回文为偶数 int len2 = maxLen(str, i, i+1); //取长度最大的 int len = len1 &gt; len2 ? len1 : len2; boolean isOdd = len1 &gt; len2; if (len &gt; maxLen) &#123; maxLen = len; if (isOdd) &#123; index = i - maxLen / 2; &#125; else &#123; index = i - maxLen / 2 + 1; &#125; &#125; &#125; return str.substring(index, index + maxLen); &#125; /** * 获取最大长度 * @param str * @param left * @param right * @return */ public static int maxLen(String str, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; str.length() &amp;&amp; str.charAt(left) == str.charAt(right)) &#123; left --; right ++; &#125; /** * 上面迭代不相等的时候，向外多扩展了一次 * 故左侧加一, 右侧减一, 又因为left, right全是下标值，默认从0开始, 故默在加上一 * (-- right) - (++ left) + 1 = (right - 1) - (left + 1) + 1 = right - left - 1; */ return right - left - 1; &#125; 解法三:动态规划(持续更新中)123```**解法四:马拉车算法实现(没听过，学习中)** `","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"leetcode-0","slug":"algorithm/leetcode-0","date":"un11fin11","updated":"un66fin66","comments":true,"path":"2019/05/20/algorithm/leetcode-0/","link":"","permalink":"http://www.note4u.cn/2019/05/20/algorithm/leetcode-0/","excerpt":"123问题: 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个","text":"123问题: 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个 12345678910111213141516171819202122232425262728实现-java/** * 1.len 小于等于0 输出null * 2.len 大于字符的字节长度, 输出整个字符 * * param encoding 编码方式**/public static String subStr(String str, int length, String encodeing) throws UnsupportedEncodingException &#123; if (length &lt;= 0) &#123; return null; &#125; int total = 0; int index = 0; for (int i = 0; i &lt; str.length(); ) &#123; String tmp = str.substring(i, ++i); total += tmp.getBytes(encodeing).length; index ++; if (total &gt;= length) &#123; break; &#125; &#125; //取较小的 index = (index &gt; str.length()) ? str.length() : index; return str.substring(0, index); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.note4u.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.note4u.cn/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://www.note4u.cn/tags/每日一题/"}]},{"title":"String.getBytes(\"utf-8\")解析","slug":"java/unicode","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2019/05/20/java/unicode/","link":"","permalink":"http://www.note4u.cn/2019/05/20/java/unicode/","excerpt":"","text":"俗话说的好，好记性不如烂笔头。之前没有对自己的所学、所用有个完整的的整理。恰巧今天是个特殊的日子，就开启我写blog的历程。 虽然工作中经常性的用 string.getBytes(&quot;utf-8&quot;), 但是对于utf8整体是如何编码的，基本处于一知半解的状态。刚好周末抽出空闲仔细看了看，将自己的一些理解记录下来。 1.Unicode的前世今生大家在工作中，常把字符集和字符编码搞混。今天我们就好好来说下unicode字符集。在计算机中，二进制的编码除了0就是1。 其中一个字节(1B)代表8位(bit)二进制数, 例如我们常说的32位机、64位机，意思指的存储器中长度最长存储32或者64个1。 1.1 ASCII因此通过1个字节组合，我们就可以标识出256个字符。于是美帝就制定了一套编码(字典)规则，用来表示英语中字符和8位二进制的对应关系，这套编码就叫做ASCII码。 ASCII一共定义了128个字符，例如大写的字母A对应的码点(字典值)是65,1234public static void main(String[] args) &#123; System.out.println((int) &apos;A&apos;); &#125; 输出65 Q: 8位二进制不是可以代表256个字符吗？ 为什么只定义了128个字符？。A: 老美设计的这套字符只是给自己或者说英语国家使用的，26个英语字母和阿拉伯数字等，128对于他们来说，完全够用了。二进制表示范围00000000-011111111。 1.2 Unicode（万国码）随着计算机的告诉发展，越来越多的国家开始大量使用计算机，但是发现老美定义的ASCII完全不够用，于是乎好多国家就自己定义很多字符集。比如大名鼎鼎的GB2312码(全称《信息交换用汉字编码字符集 基本集》)就是我们大天朝于1980年发布的一种字符编码集。 显而易见，不同国家的字符集对于同一个码点就会有不同的显示，例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。这就是我们乱码的根源(各个节点使用的编码方式不一致)。由于我没经历过那个年代，我估计那个时候的攻城狮想死的心都有。所以，Unicode字符集随着历史洪流应运而生。 简单理解Unicode就是全世界的字符字典对照表，所以俗称万国码。 1.2.1 代码空间根据Unicode定义，总共有1,114,112个代码点，编号从0x0到0x10FFFF。这些代码点构成了代码空间(Code Space) 1.2.2 代码平面Unicode将整个代码空间划分为0-16共17个代码平面(Code Plane),每个代码平面可以标识2^16(65536)个字符（17 * 2^16 == 1114112)。其中，Plane#0叫做基本多语言平面（Basic Multilingual Plane，BMP），其余平面叫做补充平面（Supplementary Planes）。Unicode7.0只使用了17个平面中的6个，并且给这6个平面起了名字，如下图所示: 下面是这些平面的名字和用途： Plane#0 BMP（Basic Multilingual Plane）大部分常用的字符都坐落在这个平面内，比如ASCII字符，汉字等。Plane#1 SMP（Supplementary Multilingual Plane）这个平面定义了一些古老的文字，不常用。Plane#2 SIP（Supplementary Ideographic Plane）这个平面主要是一些BMP中没有包含汉字。Plane#14 SSP（Supplementary Special-purpose Plane）这个平面定义了一些非图形字符。Plane#15 SPUA-A（Supplementary Private Use Area A）Plane#16 SPUA-B（Supplementary Private Use Area B） 1.2.3 数据存储刚才也说了, Unicode就是个字典表, 仅仅是对全世界的字符做了字典映射，并没有规定数据是如何存储。例如 汉字’一’对应的Unicode的16进制标识为’\\U4E00’, 如图:对应的十进制码点为19968,转换为二进制0100111000000000。显而易见，保存一个汉字一般需要2个字节(汉字 Unicode 编码范围)。由此可见，后面的字符可能需要3个甚至4个字节存储。 那具体怎么存储呢？如果直接用4个字节标识一个字符，那么对于仅需一个字节标识的ASCII码来说，要扩大3倍的存储, 原来只需要一个字节存储，现在需要4个字节。 举个不恰当的例子，我们1024M的磁盘实际存储的内容只有1024/4==256M。当然，网络传输的过程中，数据量也加大，耗费的带宽资源也扩大3倍。这显然是不可行的。所以需要重新对Unicode重新编码，于是”UTF-8”就出现了。 2.UTF-8UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8 的编码规则很简单: 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的二进制位则使用这个字符的 Unicode 码点来从后向前填充。 编码规则如下： 还是以刚才的’一’为例, 对应的码点为0x4E00 (0100 1110 0000 0000)。参照上图，4E00在0000 00080 - 0000 FFFF之间, 需要3个字节, 1110xxxx 10xxxxxx 10xxxxxx按照刚才的规则从后向前依次套入: 11100100 10111000 10000000, 转换为16进制 0xE4 0xB8 0x80。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 3.String.getBytes(“utf-8”)过程解析在使用开发的过程中, 经常使用String.getBytes(“utf-8”)获取字节码, 如图: 这个[-28, -72, -128]是怎么来的呢?我们知道, 计算机中的二进制位是以补码的形式表示的, 例如byte类型, 8位二进制。可表示的数据大小为-2^7 到 2^7-1 (即-128-127)。至于为什么使用补码详见原码, 反码, 补码 详解。 OK, 继续说”一”.getBytes(“utf-8”)的过程。 如上所述汉字’一’的Unicode码是0x4E00,用UTF-8重新编码后的二进制为 11100100 10111000 10000000。11100100 符号为1，负数。转换为补码的过程(符号位不变, 其余位取反, 然后加1)。11100100(原) = 10011011(反) = 10011100(补)。 转换为十进制值[-28]其余同理。其中: 10000000(原) (-0) 人为定义为-128。 参考博客 - - -CSDN简书","categories":[{"name":"java","slug":"java","permalink":"http://www.note4u.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.note4u.cn/tags/java/"},{"name":"utf-8","slug":"utf-8","permalink":"http://www.note4u.cn/tags/utf-8/"},{"name":"Unicode","slug":"Unicode","permalink":"http://www.note4u.cn/tags/Unicode/"}]}]}